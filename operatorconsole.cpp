/****************************************************************************	
*	Operator Console - an extensible user interface for the Imatest IT 		*
*	library																	*
*	Copyright (C) 2013 Imatest LLC.											*
*																			*
*	This program is free software: you can redistribute it and/or modify	*
*	it under the terms of the GNU General Public License as published by	*
*	the Free Software Foundation, either version 3 of the License, or		*
*	(at your option) any later version.										*
*																			*
*	This program is distributed in the hope that it will be useful,			*
*	but WITHOUT ANY WARRANTY; without even the implied warranty of			*
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the			*
*	GNU General Public License for more details.							*
*																			*
*	You should have received a copy of the GNU General Public License		*
*	along with this program.  If not, see <http://www.gnu.org/licenses/>. 	*
****************************************************************************/

///
/// OperatorConsole.cpp : Defines the class behaviors for the application.
///

#include "config.h"
#include "imatest_library.h"
#include "imatest_acquisition.h"
#include "imatestdefines.h"
#include "operatorconsole.h"
#include "operatorconsoledialog.h"
#include "setupdialog.h"
#include "passfaildialog.h"
#include "passfailsettings.h"
#include "passworddialog.h"
#include "imatestsourceids.h"
#include "waitdialog.h"
#include <sstream>
#include <QColor>
#include <QCursor>
#include <QFile>
#include <QFileInfo>
#include <QGuiApplication>
#include <QMessageBox>
#include <QTextStream>
#include <QWaitCondition>

// This REDIRECT_STDIO causes crashes on 'quit', and I'm not seeing what extra stdout data is displayed in the GUI when it is switched on.
//#define REDIRECT_STDIO				// this redirects stdout and stderr to log window using pipes and threads
#define STDIO_DEBUG				// turns on some calls printf and cout (for debugging)
#define STDOUT_BUFSIZE	32768		// this is the desired buffer size for the redirected stdout
#define START_TEST_FROM_FRAME_READY	// test (blemish or sfrplus) will be started in OnFrameReady() rather than OnStart()

//#define NO_LOG					// turns off log messages generated by the OperatorConsole object
#define LOG_FILENAME ".\\log.txt"	// contents of log window will be saved to this file when the program exits



///
/// Converts the entry<T>.value into a std::string to facilitate writing to the pass/fail file
///
template <typename T> const std::string writeEntValueString( const entry<T>& ent)
{
	stringstream ss;

	ss << ent.value;

	return ss.str();
}
///
/// Converts the entry<CString>.value into a std::string to facilitate writing to the pass/fail file
///
template <> const std::string writeEntValueString( const entry<QString>& ent)
{
	stringstream ss;

    ss << ent.value.toStdString();

	return ss.str();
}
///
/// Converts the minMaxEntry<CString>.min_val and .max_val into a std::string to facilitate writing to the pass/fail file
///
template <typename T> const std::string writeMinMaxEntValueString(const minMaxEntry<T>& ent)
{
	stringstream ss;

	ss<< ent.min_val << " " << ent.max_val;
	return ss.str();
}

///
/// Converts the vecEntry<CString>.value into a single std::string to facilitate writing to the pass/fail file
///
template <typename T> const std::string writeVecEntValueString(const vecEntry<T>& ent)
{
	stringstream ss;

	for(std::size_t idx =0 ; idx < ent.value.size(); ++idx)
	{
		ss << ent.value[idx] << " ";
	}
	return ss.str();

}

///
/// Conditionally adds a particular key (variable name) and value to the std::vector<std::string> keys, vals if the particular key is in use by the pass/fail file
///
void addKeysAndValues(const std::string& candidateKey, const std::string& candidateVal, std::vector<std::string>& keys, std::vector<std::string>& vals, bool b_addKey)
{
	if (b_addKey)
	{
		keys.push_back(candidateKey);
		vals.push_back(candidateVal);
	}
}

///
/// Adds a data_type string and key string to the std::vector<std::string> data_types and keys, respectively
///
void addDataTypeAndKey(const std::string& candidateDT, const std::string& candidateKey, std::vector<std::string>& data_types, std::vector<std::string>& keys)
{
	data_types.push_back(candidateDT);
	keys.push_back(candidateKey);
}

#ifdef INI_SEPARATE_PARAMS
void MW_CALL_CONV inifile(int nargout, mwArray& varargout, const mwArray& varargin)
{
	mwArray filePath = varargin.Get(1, 1);
	mwArray mode = varargin.Get(1, 2);

	mwArray vararginNew = mwArray(1, varargin.NumberOfElements() - 2, mxCELL_CLASS);

	for (mwSize i = 3; i <= varargin.NumberOfElements(); i++)
	{
		vararginNew.Get(1, i - 2).Set(varargin.Get(1, i));
	}

	inifile(nargout, varargout, filePath, mode, vararginNew);
}

void MW_CALL_CONV inifile(int nargout, mwArray& varargout)
{

}

void MW_CALL_CONV inifile(const mwArray& varargin)
{
	mwArray vargoutNone = mwArray();
	inifile(0, vargoutNone, varargin);
}
#endif


/// OperatorConsole construction

OperatorConsole::OperatorConsole()
{
    m_cameraImage   = nullptr;
    m_camera        = nullptr;
    m_cameraControl = nullptr;
    m_test          = nullptr;
    m_status        = idle;
    m_width         = CAMERA_WIDTH;     // placeholder value until a camera has been selected
    m_height        = CAMERA_HEIGHT;    // placeholder value until a camera has been selected

	memset(&m_flags, 0, sizeof(m_flags));
    m_PFSettings.m_ini_file = INI_FILENAME;
    m_password = ADMIN_PASSWORD;
#ifdef NO_AUTHORIZATION
	m_passFailIsUnlocked = true; // Keep this initialized to false unless you want to completely disable password-protection for pass/fail settings!
#else
	m_passFailIsUnlocked = false; // Keep this initialized to false unless you want to completely disable password-protection for pass/fail settings!
#endif
    m_image_source = no_source;
//    m_image_source = imatest_source;
//    m_image_source = file_source;   // during development, load image from a file instead of a camera
    m_logFileName = LOG_FILENAME;

    SetupSlots();
}

OperatorConsole::~OperatorConsole()
{
    Quit();         // kill all the threads
    CloseLibs();    // close libs (do this after threads are killed, in case a thread is using a lib function)

    if (m_cameraImage != nullptr)
	{
		delete [] m_cameraImage;
	}
}


/// OperatorConsole initialization

bool OperatorConsole::Init1(OperatorConsoleDialog *dialog)
{
    bool    success = true;
    m_dlg = dialog;

//	InitOutput();	// this sets up a pipe for handling stdout results from the DLLs

    if (!InitLibs()) // InitLibs must be called before any calls to Imatest library functions
    {
        cerr << "Unable to initialize the Imatest library." << endl;
    }



	if (!ReadINISettings()) // if we're unable to read the ini file, we must generate image dimensions from user input before continuing
	{
		m_setup.width = 640;
		m_setup.height = 480;
		cout << "INI settings for Operator Console not found." << endl;
		cout << "Please click the 'Setup' button and fill in the" << endl;
		cout << "appropriate fields before proceeding." << endl;

	}
	if (!ReadPassFail())
	{
        cout << "Unable to read the pass/fail file." << endl;
	}


    //
    // Initialize the Config object.  These values are used in the calls to blemish_shell() and sfrplus_shell().
    // Right now they're all hard coded (they're defined in OperatorConsole.h)
    //
    m_config.Init(INI_FILENAME, "", PROGRAMPATH, RGB_EXTENSION, FILE_ROOT, SERIAL_NUMBER, PART_NUMBER, 3);

    //
    // Copy the values into m_setup (this is passed to the setup dialog).
    // TODO: combine m_config and m_setup into a single object
    //
    m_setup.ini_file        = m_config.m_iniFilePathName.c_str();
    m_setup.chart_def_file  = m_config.m_chartDefFilePathName.c_str();
    m_setup.program_path    = m_config.m_programPath.c_str();
    m_setup.serial_number   = m_config.m_serialNumber.c_str();
    m_setup.part_number     = m_config.m_partNumber.c_str();


    if (m_image_source != no_source)
    {
        success = Init2();
    }

    if (!success)
    {
        cout << "Application Initialization Failed" << endl;
    }


    return success;
}


//////////////////////////////////////////////
///
/// Init2         perform application-specific initialization
///
/// @params        none
///
/// @return value true if successful, false otherwise
///
/// Description
///    Init does the following things:
///    It checks all of the hard coded filenames to be sure that the files exist
///    It initializes the blemish and sfrplus file acquisition objects (loads the raw files into buffers)
///    It initializes the camera object
///    Allocates a buffer to hold a single image frame
///    Creates and starts the blemish and sfrplus threads
///    Initializes the MATLAB and ImatestIT libraries
///    Initializes the blemish and sfrplus modules
///
/// If any of the initialization steps fails, an appropriate message is displayed in an Alert Box.
/////////////////////////////////////////////
bool OperatorConsole::Init2()
{
    QString	errMsg;
	bool	success = false;

    if (m_camera == nullptr)
    {
        return false;
    }

    if (!CheckFiles(errMsg))	// make sure that all of the hard coded files exist
	{
		success = false;
	}
    else if (!InitCamera())
	{
        if (m_camera != nullptr)
        {
            errMsg = m_camera->GetInfo();
        }
	}
	else if (!AllocateImageBuf())	// allocate a buffer large enough to hold an image [must be done after call to m_blemishAcq.Open()]
	{
		errMsg = "Unable to allocate image buffers.";
	}
	else if (!InitBlemishThread())
	{
		errMsg = "Unable to create Blemish thread.";
	}
	else if (!InitSFRplusThread())
	{
		errMsg = "Unable to create SFRplus thread.";
	}
	else if (!InitArbitraryChartThread())
	{
		errMsg = "Unable to create SFRplus thread.";
	}
	else if (!InitCameraThread())
	{
		errMsg = "Unable to create Capture thread.";
	}
	else
	{
        OnSetSFRplus();	// the default test is set to SFRplus
		m_status = idle;
		success = true;
	}

    if (!errMsg.isEmpty())
	{
        QMessageBox::critical(nullptr, "Error", errMsg, QMessageBox::Close);
	}

	return success;
}

bool OperatorConsole::InitCamera()
{
	bool	success = false;


//    m_image_source = file_source;    // for dev/debugging

	if (m_image_source==imatest_source)
	{
		if (m_camera->Init(m_setup.width, m_setup.height, 4))
		{
			success = m_camera->Open();
            m_imatest_cam.m_device_ID = m_setup.epiphan_deviceID;
            m_imatest_cam.m_source_ID = m_setup.sourceID;
            m_imatest_cam.m_ini_file  = m_setup.ini_file.toStdString();
		}
        m_camera = &m_imatest_cam;
	}
    else if (m_image_source==qcam_source)
    {
        success = m_qcam.Open(m_setup.qcam_deviceID);   // this calls Init for us
        m_camera = &m_qcam;
    }
	else if (m_image_source==file_source)
	{
        success = m_file_cam.Open(IMAGE_NAME);  // Open calls Init, so we don't need to do that separately
        m_camera = &m_file_cam;
    }

    if (m_camera != nullptr)
    {
        m_width   = m_camera->GetWidth();
        m_height  = m_camera->GetHeight();
        m_setup.width = m_width;
        m_setup.height = m_height;
    }

    QSize size(m_width, m_height);
    m_dlg->set_image_size(size);

    return success;
}

bool OperatorConsole::InitBlemishThread()
{
    m_blemish.Init(m_cameraImage, m_width, m_height, &m_config);
    m_flags.blemishThread = m_blemishControl.Init(m_blemish.ThreadProc, &m_blemish);

	return m_flags.blemishThread;
}


bool OperatorConsole::InitSFRplusThread()
{
    m_sfrPlus.Init(m_cameraImage, m_width, m_height, &m_config);
    m_flags.sfrplusThread = m_sfrPlusControl.Init(m_sfrPlus.ThreadProc, &m_sfrPlus);

	return m_flags.sfrplusThread;
}


bool OperatorConsole::InitArbitraryChartThread()
{
    m_arbitraryChart.Init(m_cameraImage, m_setup.width, m_setup.height, &m_config);
    m_flags.arbitraryChartThread = this->m_arbitraryChartControl.Init(m_arbitraryChart.ThreadProc, &m_arbitraryChart);

	return m_flags.sfrplusThread;
}

bool OperatorConsole::InitCameraThread()
{
    m_flags.ImatestCameraThread = m_ImatestCameraControl.Init(m_imatest_cam.ThreadProc, &m_imatest_cam);
    m_flags.FileCameraThread    = m_FileCameraControl.Init(m_file_cam.ThreadProc, &m_file_cam);
    m_flags.QCameraThread       = m_QCameraControl.Init(m_qcam.ThreadProc, &m_qcam);

    if (m_image_source == imatest_source)
	{
        SetImatestCamera();
	}
    else if (m_image_source == file_source)
	{
        SetQCamera();
	}
    else if (m_image_source == file_source)
    {
        SetFileCamera();
    }
    return (m_flags.ImatestCameraThread && m_flags.QCameraThread);
}



bool OperatorConsole::InitLibs()
{
    QString	str;

    m_flags.matlab = mclInitializeApplication(nullptr, 0);	// try to initialize the MATLAB library

	if (!m_flags.matlab)
	{
		str = "Unable to initialize MATLAB library";
	}
	else
	{
		//
		// Try to initialize Blemish and SFRplus libraries
		//
		m_flags.imatestIT = imatest_libraryInitialize();

		if (!m_flags.imatestIT)
		{
			str = "Unable to initialize imatest library.";
		}

		m_flags.imatestAcq = imatest_acquisitionInitialize();

		if (!m_flags.imatestAcq)
		{
			str = "Unable to initialize imatest acquisition library.";
		}
	}

    if (!str.isEmpty())
	{
        QMessageBox::critical(nullptr, "InitLibs Error", str, QMessageBox::Close);
	}

	return m_flags.matlab && m_flags.imatestIT && m_flags.imatestAcq;
}

void OperatorConsole::CloseLibs()
{
	if (m_flags.imatestIT)
	{
		imatest_libraryTerminate();
		m_flags.imatestIT = false;
	}

	if (m_flags.imatestAcq)
	{
		imatest_acquisitionTerminate();
		m_flags.imatestAcq = false;
	}

	if (m_flags.matlab)
	{
		mclTerminateApplication();	// terminate MATLAB runtime
		m_flags.matlab = false;
	}
}


bool OperatorConsole::InitOutput()
{
	m_flags.stdOut = false;
	m_flags.stdErr = false;

#if defined REDIRECT_STDIO
	m_stdoutThread.InitThread(STDOUT_BUFSIZE, MSG_STDOUT, m_nThreadID);
	m_stderrThread.InitThread(STDOUT_BUFSIZE, MSG_STDERR, m_nThreadID);
	m_flags.stdOut = true;
	m_flags.stdErr = true;
#endif

	return m_flags.stdOut && m_flags.stdErr;
}


bool OperatorConsole::AllocateImageBuf()
{
    bool    success = true;

    if (m_camera != nullptr)
    {
        if (m_cameraImage != nullptr)
        {
            delete [] m_cameraImage;
        }

        // TODO: wrap in try block and catch exception if alloc fails
        m_cameraImage = new byte[m_camera->BytesPerFrame()];
        success = m_cameraImage != nullptr;
    }
    return success;
}


void OperatorConsole::OnSetBlemish()
{
	m_test = &m_blemishControl;
    m_dlg->qsoShow(false);
}

void OperatorConsole::OnSetSFRplus()
{
	m_test = &m_sfrPlusControl;
}

void OperatorConsole::OnSetArbitraryChart()
{
	m_test = &m_arbitraryChartControl;
    m_dlg->qsoShow(false);
}


void OperatorConsole::OnStart()	// the Start button was pressed in the dialog
{
    if (m_status == idle)
	{
		m_status = runningTest;
        OnRunTest();
	}
}

void OperatorConsole::OnStop()
{
    if (m_status == runningTest)
    {
        m_status = stopping;
        m_wait.start();
    }
    else
    {
        m_status = idle;	// any test in progress will finish, but a new one won't be started
    }
}

void OperatorConsole::OnShowJSON()
{
    if (m_jsonDialog.isVisible())
    {
        m_jsonDialog.hide();
    }
    else
    {
        m_jsonDialog.setText(m_results.json);
        m_jsonDialog.setTitle(m_results.name);
        m_jsonDialog.show();
    }
}

void OperatorConsole::Quit()
{
	///
	/// This function gets called when the user wants to Quit the application (either by closing the window or
	/// pressing the Quit button).  Before we quit, we need to wait for the blemish and sfrplus threads to 
	/// finish.
	/// 
	/// We tell the threads to finish by sending a Quit message to them.  However, if a test is in progress,
	/// that thread won't process the Quit message until the test finished.  This can take a few seconds, so
	/// we post a Log message and turn on the Wait cursor until the threads finish.
	///
    QCursor waitcursor(Qt::WaitCursor);

	m_status = quitting;		// this tells us not to run another test

    if (m_flags.QCameraThread)
    {
        m_QCameraControl.Quit(); // wait for the DirectShow camera thread to quit
        m_flags.QCameraThread = false;
    }

    if (m_flags.ImatestCameraThread)
    {
        m_ImatestCameraControl.Quit(); // wait for the Imatest library camera thread to quit
        m_flags.ImatestCameraThread = false;
    }

    if (m_flags.FileCameraThread)
    {
        m_FileCameraControl.Quit(); // wait for the Imatest library camera thread to quit
        m_flags.FileCameraThread = false;
    }

    if (m_flags.sfrplusThread)
	{
		m_sfrPlusControl.Quit();	// wait for the sfrplus thread to quit
		m_flags.sfrplusThread = false;
	}

	if (m_flags.blemishThread)
	{
		m_blemishControl.Quit();	// wait for the blemish thread to quit
		m_flags.blemishThread = false;
	}

#if defined(REDIRECT_STDIO)
	if (m_flags.stdOut)
	{
		m_stdoutThread.Quit();		// close the stdout pipe and wait for the thread to quit
		m_flags.stdOut = false;
	}
	if (m_flags.stdErr)
	{
		m_stderrThread.Quit();		// close the stderr pipe and wait for the thread to quit
		m_flags.stdErr = false;
	}
#endif
	// TDC 2014/08/07 Calling SaveLog() anywhere in Quit() will NOT copy the contents of 
	// c_log as c_log.GetWindowText returns an empty string instead of the contents of c_log. Additionally,
	// if you use SetSel to set to the entire edit box, the values it returns have nStart > nStop.
	//SaveLog(LOG_FILENAME); 
	
	
}

void OperatorConsole::OnRunTest()
{
#if !defined NO_LOG
    QString str;
    QTextStream text(&str);

    text << GetTestName() << " started\n";
    LogMessage(text);
#endif

    m_cameraControl->Run();	// capture 1 frame from the camera (we'll run the test after the frame is captured)
}

void OperatorConsole::OnFrameReady()
{
    //
    // There appears to be a potential problem here when the application is quitting:  if the FrameReady
    // signal is received after m_camera's destructor has been called, this function would be trying to
    // access an object that no longer exists.
    //
#if 1
    if (m_status == runningTest)
    {
        m_camera->GetFrame(m_cameraImage);  // copy image data from camnera object's shared buffer
        m_test->Run();                      // tell the thread to run 1 test (it will send our thread a message when it's done)
    }
#else
    //
    // Display the image and start another captyure.  This bypasses the test (useful during development)
    //
    m_camera->GetFrame(m_cameraImage);  // copy image data from camnera object's shared buffer
    QImage image(m_cameraImage, m_width, m_height, QImage::Format_RGB32);   // convert camera data to an image
    m_dlg->update_image(image);                                             // display the image in the dialog
    m_cameraControl->Run();
#endif
}

void OperatorConsole::OnBlemishDone()
{
	if (m_status != quitting)
	{
		UpdateResults(&m_blemish);	// right now blemish doesn't have any special results, so we can just call UpdateResults() directly
        TestDone();
	}
}

void OperatorConsole::OnSFRplusDone()
{
	if (m_status != quitting)
	{
		UpdateResultsSFRplus(&m_sfrPlus);
        TestDone();
    }
}


void OperatorConsole::OnAribtraryChartDone()
{
	if (m_status != quitting)
	{
		UpdateResults(&m_arbitraryChart);	// right now arbitrary chart doesn't have any special results, so we can just call UpdateResults() directly
        TestDone();
    }
}

void OperatorConsole::OnUpdateStdout()
{
//	GetStdoutMsg(m_stdoutThread, m_stdoutStr);
}

void OperatorConsole::OnUpdateStderr()
{
//	GetStdoutMsg(m_stderrThread, m_stderrStr);
}


//void OperatorConsole::GetStdoutMsg(StdoutThread &data, QString &str)
//{

//	data.Get(str, true);			// get the message

//    if (!str.isEmpty())
//	{
//        str.replace("\n", "\r\n");		// convert \n to \r\n
//        LogMessage(str);                // copy the message to the log display in the dialog
//	}
//}

void OperatorConsole::UpdateResultsSFRplus(ImageTest *test)
{
    const bool  *qso = 	m_sfrPlus.GetQSO(); // QSO overlay (tic-tac-toe)

	UpdateResults(test);

    m_dlg->update_quadrants(qso);
    m_dlg->qsoShow(true);
}


void OperatorConsole::UpdateResults(ImageTest *test)
{
    QString		str;
    QTextStream text(&str);
    bool		passed = test->Passed();


#if !defined NO_LOG
    text << test->m_name << " took " << test->m_elapsedStr << " sec\n";
    LogMessage(text);
#endif

#if defined START_TEST_FROM_FRAME_READY
    QImage image(m_cameraImage, m_width, m_height, QImage::Format_RGB32);   // convert camera data to an image
    m_dlg->update_image(image);                                             // display the image in the dialog
#endif

	//
	// Copy strings from the test object into our application
	// object so that we can display them in the dialog.
	//
	GetResults(test);

	//
    // Update the dialog with the test results.  The functions below just call functions in the
    // dialog, so we can probably just call the dialog functions here.
	//
    LogMessage(m_results.log, false);			// update any log messages from the test
    UpdateStatus(passed, m_results.failInfo);	// status (pass/fail)
    UpdateSummary(m_results.summary);			// summary (results)
    UpdateFPS(test->m_elapsedStr);				// frame rate

	//
	// Update the values in the json string, replacing \n with \r\n so
	// that the line breaks will work when displayed in a dialog.
	// 
    m_results.json = m_results.json.replace("\n", "\r\n");
}

void OperatorConsole::GetResults(ImageTest *test)
{
	test->GetSummary(m_results.summary);	// the summary results of the test (these get displayed in the dialog)
	test->GetFailInfo(m_results.failInfo);	// reasons that image failed the test
	test->GetLog(m_results.log);			// log message(s)
	test->GetName(m_results.name);			// the name of the test that was run
	test->GetJSON(m_results.json);
}

void OperatorConsole::LogTime()
{
    QTime	t   = QTime::currentTime();
    QString	str = t.toString(Qt::DefaultLocaleShortDate);
    LogMessage(str);
}

BOOL OperatorConsole::SendAppMessage(int msg)
{
    bool	result = true;

//	result = ::PostThreadMessage(m_nThreadID, msg, 0, 0);

    return result;
}


bool OperatorConsole::CheckFiles(QString &msg)
{
    const char	*files[] = {LOGO_NAME, INI_FILENAME};
	int			numFiles = sizeof(files) / sizeof (*files);
	int			i;
    QString     filename;
	bool		success = true;

    msg.clear();

	//
	// Try to open all of the hard-coded files.  
	//
	for (i = 0; i < numFiles; i++)
	{
        filename = files[i];
        if (!QFile::exists(filename))
		{
            msg.append(filename);
            msg.append(" not found\r\n");
			success = false;
		}
	}

	return success;
}

void OperatorConsole::SaveLog(void)
{
	SaveLog(m_logFileName);
}


void OperatorConsole::SaveLog(const QString& filePathName)
{
//	UINT	len;
//    QString	str;
//	CFile	file(filePathName, CFile::modeWrite | CFile::modeCreate);
	
    // We need a QFile and a text stream.  We can write to the file using the stream
    // We also need a way to get the log text from the main window.  We may need to send a signal to the main window
    // and then wait for a return signal.  Or we can have the main window save the log by sending a signal with the filename.
    //
    // I like the idea of sa

	//
	// Copy the contents of the log window into a string
	//
//	if (m_pMainWnd){
//		((COperatorConsoleDlg *)m_pMainWnd)->GetLog(str);
//	}
	
//	//
//	// str may have lines ending with \r\n or just \n.  We want all lines to end with \r\n, so first we need to
//	// convert any \r\n combinations to \n.  Then we can go back and replace all of the \n characters with \r\n.
//	//
//    str = str.replace("\r\n", "\n");
//    str = str.replace("\n", "\r\n");
//    len = static_cast<uint>(str.length());

//	//
//	// Write the string to a file.  Note that the file has *not* been opened in TEXT mode.
//	// This means that the string will be written to the file as-is.  There will be *no*
//	// automatic replacing of \n with \r\n.  That's okay, because the text from the
//	// log window already has \r\n in it.
//	//
//	file.Write(str, len);
//	file.Close();
}


void OperatorConsole::OnSetup()
{
    int oldWidth = m_setup.width;
    int oldHeight = m_setup.height;
    int oldSourceID = m_setup.sourceID;
    QString oldQCamID = m_setup.qcam_deviceID;

    // Update the list of dynamically detected devices.
    m_setup.device_infos = m_imatest_cam.GetAttachedDevices();

    SetupDialog dialog(m_setup, m_dlg);

    int result = dialog.exec();

    if (result == QDialog::Accepted)
    {
        m_setup = dialog.GetSettings();
        m_imatest_cam.m_device_ID = m_setup.epiphan_deviceID;
        m_imatest_cam.m_source_ID = m_setup.sourceID;
        m_imatest_cam.m_ini_file  = m_setup.ini_file.toStdString();

        // transfer the configuration details to the other classes
        m_config.m_iniFilePathName = m_setup.ini_file.toStdString();
        m_config.m_chartDefFilePathName = m_setup.chart_def_file.toStdString();
        m_config.m_serialNumber = m_setup.serial_number.toStdString();
        m_config.m_partNumber = m_setup.part_number.toStdString();
        m_config.m_programPath = m_setup.program_path.toStdString();

        //
        // These are no longer member variables in the ImageTest class (m_config gets passed in instead)
        //
#if 0
        m_blemish.m_iniFilePathName = &m_config.m_iniFilePathName.toStdString();
        m_blemish.m_serialNumber = &m_config.m_serialNumber.toStdString();
        m_blemish.m_partNumber = &m_config.m_partNumber.toStdString();
        m_blemish.m_programPath = &m_config.m_programPath.toStdString();

        m_sfrPlus.m_iniFilePathName = &m_config.m_iniFilePathName.toStdString();
        m_sfrPlus.m_serialNumber = &m_config.m_serialNumber.toStdString();
        m_sfrPlus.m_partNumber = &m_config.m_partNumber.toStdString();
        m_sfrPlus.m_programPath = &m_config.m_programPath.toStdString();

        m_arbitraryChart.m_iniFilePathName = &m_config.m_iniFilePathName.toStdString();
        m_arbitraryChart.m_serialNumber = &m_config.m_serialNumber.toStdString();
        m_arbitraryChart.m_partNumber = &m_config.m_partNumber.toStdString();
        m_arbitraryChart.m_programPath = &m_config.m_programPath.toStdString();
        m_arbitraryChart.m_chartDefFilePathName = &m_config.m_chartDefFilePathName.toStdString();
#endif
        WriteINISettings(); // store new settings
        if (oldWidth != m_setup.width || oldHeight != m_setup.height
            || ((oldSourceID != SOURCE_OpConsoleDirectShow) && (m_setup.sourceID == SOURCE_OpConsoleDirectShow))
            || ((oldSourceID == SOURCE_OpConsoleDirectShow) && (m_setup.sourceID != SOURCE_OpConsoleDirectShow))
            || ((oldSourceID == SOURCE_OpConsoleDirectShow) && (oldQCamID != m_setup.qcam_deviceID)))
        {

            if (m_setup.sourceID != SOURCE_OpConsoleDirectShow)
            {
                m_image_source = imatest_source;

                if (oldSourceID == SOURCE_OpConsoleDirectShow)
                {
                    SetImatestCamera();
                }
            }
            else
            {
                m_image_source = qcam_source;

                if (oldSourceID != SOURCE_OpConsoleDirectShow || (oldQCamID != m_setup.qcam_deviceID))
                {
                    SetQCamera();
                }
            }
            // image dimensions have changed, so we must reallocate
            try
            {
                if (!ReInit())
                {
                    cout << "Unable to reinitialize." << endl;
                }
            }
            catch (std::exception & ex)
            {
                cout << "Error occurred during reinitialization." << endl;
                cerr << ex.what() << endl;
            }
        }
    }
}

///
/// This function reads in items for the setup dialog from imatest.ini
///

bool OperatorConsole::ReadINISettings(void)
{
    // TODO: create a IniSettings class heirarchy that abstracts away the mwArray generation
    bool result = false;
	mwArray vararginParam = mwArray(1,3,mxCELL_CLASS);
	mwArray readKeys = mwArray(1,5,mxCELL_CLASS);
	mwArray inifilename(INI_FILENAME);
	mwArray mode("read");
	mwArray section_ovt("ovt"),section_imatest("imatest"),section_op("op_console"),section;
	mwArray subsection_blank(""), subsection_current("current"),subsection;
	mwArray key_acquire("acquire"),key_width("width"),key_height("height"),key_bitdepth("bitdepth"),key_bayer("bayer_pattern"),key_omniregister("register_files"),key_epiphan_deviceid("deviceID");
    mwArray key_vid_format("vid_format");
    mwArray value_int("i"), value_string(""), value_double("d");
	mwArray default_0(0), default_emptystring("");
	mwSize getIndex = 1;
	// NOTE: the mwArray::Get function has input syntax Get(number of indexes, i1, i2,...in)

	// first read the 'acquire' key from [imatest]
	getIndex = 1;
	readKeys.Get(2,1,getIndex++).Set(section_imatest);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,1,getIndex++).Set(subsection_blank);
#endif
	readKeys.Get(2, 1, getIndex++).Set(key_acquire);
	readKeys.Get(2, 1, getIndex++).Set(value_int);
	readKeys.Get(2, 1, getIndex++).Set(default_0);
	
	vararginParam.Get(2,1,1).Set(inifilename);
	vararginParam.Get(2,1,2).Set(mode);
	vararginParam.Get(2,1,3).Set(readKeys);
	mwArray readSett = mwArray(1,1,mxCELL_CLASS);
	int temp_source_id = m_setup.sourceID;
	try
	{
        inifile(1, readSett,vararginParam);
        temp_source_id = static_cast<int>(readSett.Get(1,1).Get(1,1).Get(1,1));
		m_setup.sourceID = temp_source_id;

	}
	catch (mwException& e)
	{
		cout << "Run Error!" << endl;
		cerr << e.what() << endl;
		e.print_stack_trace();
	}	

	if (m_setup.sourceID ==2)
	{
		section = section_ovt;
		subsection = subsection_current;
	}
	else
	{
		section = section_op;
		subsection = subsection_blank;
	}

    readKeys = mwArray(7,5,mxCELL_CLASS);
	// to read the Epiphan 'device_ID' key 
	getIndex = 1;
	readKeys.Get(2,1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,1,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,1,getIndex++).Set(key_epiphan_deviceid);
	readKeys.Get(2,1,getIndex++).Set(value_int);
	readKeys.Get(2,1,getIndex++).Set(default_0);

	// to read the 'width' key 
	getIndex = 1;
	readKeys.Get(2,2,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,2,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,2,getIndex++).Set(key_width);
	readKeys.Get(2,2,getIndex++).Set(value_int);
	readKeys.Get(2,2,getIndex++).Set(default_0);

	// to read the 'height' key 
	getIndex = 1;
	readKeys.Get(2,3,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,3,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,3,getIndex++).Set(key_height);
	readKeys.Get(2,3,getIndex++).Set(value_int);
	readKeys.Get(2,3,getIndex++).Set(default_0);

	// to read the 'bitdepth' key 
	getIndex = 1;
	readKeys.Get(2,4,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,4,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,4,getIndex++).Set(key_bitdepth);
	readKeys.Get(2,4,getIndex++).Set(value_int);
	readKeys.Get(2,4,getIndex++).Set(default_0);

	// to read the 'bayer_pattern' key
	getIndex = 1;
	readKeys.Get(2,5,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,5,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,5,getIndex++).Set(key_bayer);
	readKeys.Get(2,5,getIndex++).Set(value_int);
	readKeys.Get(2,5,getIndex++).Set(default_0);

	// to read the 'register_files' key
	getIndex = 1;
	readKeys.Get(2,6,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	readKeys.Get(2,6,getIndex++).Set(subsection);
#endif
	readKeys.Get(2,6,getIndex++).Set(key_omniregister);
	readKeys.Get(2,6,getIndex++).Set(value_string);
	readKeys.Get(2,6,getIndex++).Set(default_emptystring);

    // first read the 'acquire' key from [imatest]
    getIndex = 1;
    readKeys.Get(2, 7,getIndex++).Set(section_imatest);
#ifdef INI_INCLUDE_SUBSECTION
    readKeys.Get(2, 7,getIndex++).Set(subsection_blank);
#endif
    readKeys.Get(2, 7, getIndex++).Set(key_vid_format);
    readKeys.Get(2, 7, getIndex++).Set(value_string);
    readKeys.Get(2, 7, getIndex++).Set(default_emptystring);

	vararginParam.Get(1,1).Set(inifilename);
	vararginParam.Get(1,2).Set(mode);
	vararginParam.Get(1,3).Set(readKeys);

    readSett = mwArray(1,7,mxCELL_CLASS);
	int temp_epiphan_deviceid = m_setup.epiphan_deviceID;
	int temp_width = m_setup.width;
	int temp_height = m_setup.height;
	int temp_bits_per_pixel = m_setup.bits_per_pixel;
	int temp_bayer = m_setup.bayer;
    std::string temp_reg_file = m_setup.omnivision_reg_file.toStdString();
    std::string temp_vid_format = m_setup.video_format.toStdString();
	try
	{
        inifile(1, readSett,vararginParam);
        mwArray settings = readSett.Get(1,1);
        temp_epiphan_deviceid =	static_cast<int>(settings.Get(1,1).Get(1,1));
        temp_width =			static_cast<int>(settings.Get(1,2).Get(1,1));
        temp_height =			static_cast<int>(settings.Get(1,3).Get(1,1));
        temp_bits_per_pixel =	static_cast<int>(settings.Get(1,4).Get(1,1));
        temp_bayer =			static_cast<int>(settings.Get(1,5).Get(1,1));
        temp_reg_file =			settings.Get(1,6).ToString();
        temp_vid_format =       settings.Get(1,7).ToString();

		// copy the values into the corresponding fields in m_setup
		m_setup.epiphan_deviceID =		temp_epiphan_deviceid;
		m_setup.width =					temp_width;
		m_setup.height =				temp_height;
		m_setup.bits_per_pixel =		temp_bits_per_pixel;
		m_setup.bayer =					temp_bayer;
        m_setup.omnivision_reg_file =	temp_reg_file.c_str();
        m_setup.video_format = QString(temp_vid_format.c_str());

		// change the image source if needed
		if (m_setup.sourceID != SOURCE_OpConsoleDirectShow)
		{
			m_image_source=imatest_source;
            SetImatestCamera();
        }
		else
		{
            m_image_source=file_source;
            SetQCamera();
		}
	}
	catch (mwException& e)
	{
		cout << "Run Error!" << endl;
		cerr << e.what() << endl;
		e.print_stack_trace();

	}	

//    m_setup.omnivision_reg_file.remove('\n'); // inifile() reads newline and carriage return characters into the string
//    m_setup.omnivision_reg_file.remove('\r'); // which causes the setup window to be unable to find the file. These characters must be removed.

    if (m_setup.omnivision_reg_file.compare("[]")==0) // Matlab returns empty strings slightly differently when cells are involved...
	{
		m_setup.omnivision_reg_file="";
	}

	if ( m_setup.width > 0 && m_setup.height > 0) // we must have the width and height > 0 since we will be allocating buffers soon
	{
		result = true;
	}

	return result;
}
//
// This function writes various items used in the setup dialog to imatest.ini
// 
void OperatorConsole::WriteINISettings(void)
{
	mwArray vararginParam = mwArray(1,4,mxCELL_CLASS);
    mwArray writeKeys = mwArray(8,4,mxCELL_CLASS);
    mwArray inifilename(m_config.m_iniFilePathName.c_str());
	mwArray mode("write"),style("plain");
	mwArray section_ovt("ovt"),section_imatest("imatest"),section_op("op_console"),section("");
	mwArray subsection_blank(""), subsection_current("current"),subsection("");
	mwArray key_acquire("acquire"),key_width("width"),key_height("height"),key_bitdepth("bitdepth");
	mwArray key_bayer("bayer_pattern"),key_omniregister("register_files"),key_epiphan_deviceid("deviceID");
    mwArray key_vid_format("vid_format");
	mwArray val_acquire(m_setup.sourceID), val_width(m_setup.width), val_height(m_setup.height), val_bitdepth(m_setup.bits_per_pixel);
    mwArray val_bayer(m_setup.bayer), val_omniregister(m_setup.omnivision_reg_file.toStdString().c_str()), val_epiphan_deviceid(m_setup.epiphan_deviceID);
    mwArray val_vid_format(m_setup.video_format.toStdString().c_str());
	mwSize getIndex = 1;
	// NOTE: the mwArray::Get function has input syntax Get(number of indexes, i1, i2,...in)
	// first read the 'acquire' key from [imatest]
	getIndex = 1;
	writeKeys.Get(2,1,getIndex++).Set(section_imatest);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,1,getIndex++).Set(subsection_blank);
#endif
	writeKeys.Get(2,1,getIndex++).Set(key_acquire);
	writeKeys.Get(2,1,getIndex++).Set(val_acquire);

	if (m_setup.sourceID == SOURCE_Omnivision) // Omnivision
	{
		section = section_ovt;
		subsection = subsection_current;
	}
	else
	{
		section = section_op;
		subsection = subsection_blank;
	}

	// to write the Epiphan 'device_ID' key 
	getIndex = 1;
	writeKeys.Get(2,2,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,2,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,2,getIndex++).Set(key_epiphan_deviceid);
	writeKeys.Get(2,2,getIndex++).Set(val_epiphan_deviceid);

	// to write the 'width' key 
	getIndex = 1;
	writeKeys.Get(2,3,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,3,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,3,getIndex++).Set(key_width);
	writeKeys.Get(2,3,getIndex++).Set(val_width);


	// to write the 'height' key 
	getIndex = 1;
	writeKeys.Get(2,4,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,4,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,4,getIndex++).Set(key_height);
	writeKeys.Get(2,4,getIndex++).Set(val_height);


	// to write the 'bitdepth' key 
	getIndex = 1;
	writeKeys.Get(2,5,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,5,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,5,getIndex++).Set(key_bitdepth);
	writeKeys.Get(2,5,getIndex++).Set(val_bitdepth);


	// to write the 'bayer_pattern' 
	getIndex = 1;
	writeKeys.Get(2,6,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,6,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,6,getIndex++).Set(key_bayer);
	writeKeys.Get(2,6,getIndex++).Set(val_bayer);


	// to write the 'register_files' 
	getIndex = 1;
	writeKeys.Get(2,7,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
	writeKeys.Get(2,7,getIndex++).Set(subsection);
#endif
	writeKeys.Get(2,7,getIndex++).Set(key_omniregister);
	writeKeys.Get(2,7,getIndex++).Set(val_omniregister);

    // to write the 'register_files'
    getIndex = 1;
    writeKeys.Get(2,8,getIndex++).Set(section_imatest);
#ifdef INI_INCLUDE_SUBSECTION
    writeKeys.Get(2,8,getIndex++).Set(subsection);
#endif
    writeKeys.Get(2,8,getIndex++).Set(key_vid_format);
    writeKeys.Get(2,8,getIndex++).Set(val_vid_format);

    vararginParam.Get(2,1,1).Set(inifilename);
	vararginParam.Get(2,1,2).Set(mode);
	vararginParam.Get(2,1,3).Set(writeKeys);
	vararginParam.Get(2,1,4).Set(style);
	try 
	{
         inifile(vararginParam);
    }

    catch (mwException& e)
	{
		cout << "Run Error!" << endl;
		cerr << e.what() << endl;
		e.print_stack_trace();
	}
}

//
// This function allows for reallocation of the various image buffers when we change the image size
//
bool OperatorConsole::ReInit(void)
{

    QString	errMsg;
	bool	success = false;

	m_sfrPlusControl.Quit();
	m_blemishControl.Quit();
    m_arbitraryChartControl.Quit();

	if (!CheckFiles(errMsg))	// make sure that all of the hard coded files exist
	{
		success = false;
	}
    else if (!InitCamera())
	{
		errMsg = m_camera->GetInfo();
	}
    else if (!AllocateImageBuf())	// allocate a buffer large enough to hold an image [must be done after call to m_blemishAcq.Open()]
	{
		errMsg = "Unable to allocate image buffers.";
	}
	else if (!InitBlemishThread())
	{
		errMsg = "Unable to create Blemish thread.";
	}
	else if (!InitSFRplusThread())
	{
		errMsg = "Unable to create SFRplus thread.";
	}
    else if (!InitArbitraryChartThread())
    {
        errMsg = "Unable to create SFRplus thread.";
    }
    else if (!InitCameraThread())
    {
        errMsg = "Unable to create Capture thread.";
    }
    else
	{
//        OnSetSFRplus();	// the default test is set to SFRplus
		m_status = idle;
		success = true;
//        ((OperatorConsoleDlg *)m_pMainWnd)->ReInitDialog();
	}


    if (!errMsg.isEmpty())
	{
        QMessageBox::critical(nullptr, "Init Error", errMsg);
	}

	return success;

}

bool OperatorConsole::GetPassword()
{
    PasswordDialog  pwdDialog(m_dlg);
    bool            success = false;

    if (pwdDialog.exec() == QDialog::Accepted)
    {
        if (m_password.compare(pwdDialog.getResponse()) ==0)
        {
            m_passFailIsUnlocked = pwdDialog.getUnlockStatus();
            success = true;
        }
        else
        {
            cout << "Incorrect password." << endl;
        }
    }

    return success;
}

void OperatorConsole::OnPassFail()
{
    if (m_passFailIsUnlocked || GetPassword())
    {
//        PassFailDialog passfail(m_PFSettings, nullptr);

//        if (passfail.exec() == QDialog::Accepted)
//        {
//            if (!m_PFSettings.b_isReadOnly)
//            {
//                m_PFSettings = passfail.PFSettings;
//                WritePassFail();
//            }
//            else
//            {
//                cout << "Pass/Fail file is read-only. No changes were saved." << endl;
//            }
//        }
    }
}

bool OperatorConsole::ReadPassFail(void)
{
	bool result=false;

    // First we must find the name of the Pass/Fail file as listed in imatest.ini
    mwArray vararginParam = mwArray(1,3,mxCELL_CLASS);
    mwArray readKeys = mwArray(1,5,mxCELL_CLASS);
    mwArray inifilename(m_PFSettings.m_ini_file.c_str());
    mwArray mode("read");
    mwArray section("api");
    mwArray subsection_blank("");
    mwArray key_passFail("passFail");
    mwArray value_int("i"), value_string(""), value_double("d");
    int badval = -123456;
    std::string badstring = "-123456%^&%%$**#";
    mwArray default_0(badval), default_emptystring(badstring.c_str()),default_dbl(static_cast<double>(badval));
    mwSize getIndex = 1;

    getIndex = 1;
    readKeys.Get(1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
    readKeys.Get(1,getIndex++).Set(subsection_blank);
#endif
    readKeys.Get(1,getIndex++).Set(key_passFail);
    readKeys.Get(1,getIndex++).Set(value_string);
    readKeys.Get(1,getIndex++).Set(default_emptystring);

    vararginParam.Get(1,1).Set(inifilename);
    vararginParam.Get(1,2).Set(mode);
    vararginParam.Get(1,3).Set(readKeys);

    mwArray readSett = mwArray(1,1,mxCELL_CLASS);
    try
    {
        inifile(1,readSett,vararginParam);
    }
    catch (mwException& e)
    {
        cout << "Run Error! Unable to read Pass/Fail file" << endl;
        cerr << e.what() << endl;
        e.print_stack_trace();
    }

    mwArray readSettContainer = readSett.Get(1, 1);

    if (readSettContainer.NumberOfElements() > 0)
    {
        m_PFSettings.m_pass_fail_file = readSett.Get(1, 1).Get(1, 1).ToString();
//        m_PFSettings.m_pass_fail_file.remove('\n');
//        m_PFSettings.m_pass_fail_file.remove('\r');
    }
    else
    {
        /// inifile failed
        cout << "Run Error! Unable to read Pass/Fail file" << endl;
    }
    //Now we find the Pass/Fail file and check if it is read-only

    QString ini_name = m_PFSettings.m_pass_fail_file.c_str();
    QFileInfo info(ini_name);
    if (!info.isWritable())
    {
        m_PFSettings.b_isReadOnly = TRUE;
    }

    // Next we need to figure out which pass/fail modules are in the ini. We will just 'readAll', which returns the full list of sections.
    //[keys,sections,subsections] = INIFILE(fName,'readall')

    mwArray keys;
    mwArray sections;
    mwArray subsections;
    mwArray passFailFile(m_PFSettings.m_pass_fail_file.c_str());
    mwArray mode_readall("readall"),mode_read("read");
#ifdef INI_INCLUDE_SUBSECTION
    int numArgOut = 3;
#else
    int numArgOut = 2;
#endif
    mwArray varargout = mwArray(1,static_cast<mwSize>(numArgOut),mxCELL_CLASS);

    varargout.Get(1,1).Set(keys);
    varargout.Get(1,2).Set(sections);
#ifdef INI_INCLUDE_SUBSECTION
    varargout.Get(1,3).Set(subsections);
#endif

    mwArray varargin = mwArray(1,2,mxCELL_CLASS);
    varargin.Get(1,1).Set(passFailFile);
    varargin.Get(1,2).Set(mode_readall);
    try
    {

        inifile(numArgOut, varargout, varargin);
    }
    catch (mwException& e)
    {
        cout << "Run Error! Unable to read Pass/Fail file" << endl;
        cerr << e.what() << endl;
        e.print_stack_trace();
    }

    std::size_t numSections = varargout.Get(1,2).NumberOfElements();
    for (std::size_t idx = 1; idx <= numSections; ++idx)
    {
        QString section = (const char *)varargout.Get(1,2).Get(1,idx).ToString();

        section.remove('\n');
        section.remove('\r');

        if (section.compare("SFRplus", Qt::CaseInsensitive) ==0)
        {
            m_PFSettings.sfrplus.b_enable = true;
        }
        else if(section.compare("Blemish", Qt::CaseInsensitive)==0)
        {
            m_PFSettings.blemish.b_enable = true;
        }
        else if(section.compare("OIS", Qt::CaseInsensitive)==0)
        {
            m_PFSettings.ois.b_enable = true;
        }
        else
        {
            m_PFSettings.other.b_enable = true;
            m_PFSettings.other.name = section.toStdString();
        }
    }

    // Next we can read in the keys for the 'other' section from what we already have for which all values are strings

    // Section index is different for 4.2
#ifdef INI_INCLUDE_SUBSECTION
    mwSize sectionIndex = 1;
#else
    mwSize sectionIndex = 2;
#endif
	
    /*
    if (m_PFSettings.other.b_enable)
    {
        mwArray dims = varargout.Get(1,1).GetDimensions();
        std::vector<int> vdims;
        std::size_t arr_dims = varargout.Get(1,1).NumberOfDimensions();

        vdims.resize(arr_dims);

        dims.GetData(&vdims[0], arr_dims);
        std::size_t numRows = (std::size_t)vdims[0];
        for (std::size_t idx=1; idx <=numRows; ++idx)
        {
            CString section = _T(varargout.Get(1,sectionIndex).Get(2,idx,1).ToString());
            section.Remove('\n');
            section.Remove('\r');
            CString cstrkey;
            CString cstrval;
            entry<CString> ent;
            if (section.CompareNoCase(m_PFSettings.other.name) ==0)
            {
                cstrkey = _T(varargout.Get(1,1).Get(2,idx,3).ToString());
                cstrkey.Remove('\n');
                cstrkey.Remove('\r');
                cstrval = _T(varargout.Get(1,1).Get(2,idx,4).ToString());
                cstrval.Remove('\n');
                cstrval.Remove('\r');
                ent.name = cstrkey;
                ent.value = cstrval;
                ent.data_type = "";
                ent.description = _T("");
                m_PFSettings.other.ent_vec.push_back(ent);
            }
        }


    }
    */
    // Now we get to read in the other sections in a manner that respects their data type since a few of the inputs are vectors.
    // Now is a good time to grab a cup of tea...

    if (m_PFSettings.blemish.b_enable)
    {

#ifdef INI_INCLUDE_SUBSECTION
        readKeys = mwArray(m_PFSettings.blemish.numEntries, 5, mxCELL_CLASS);
#else
        readKeys = mwArray(m_PFSettings.blemish.numEntries, 4, mxCELL_CLASS);
#endif

        mwArray section_Blemish(m_PFSettings.blemish.name.c_str());

        varargin = mwArray(1,3,mxCELL_CLASS);
		
        std::vector<std::string> data_types;
        std::vector<std::string> blem_keys;
        // the entry<T> corresponding to a given index in blem_keys will correspond to the same index + 1 in readKeys
        addDataTypeAndKey(m_PFSettings.blemish.Blemish_maximum_count.data_type, m_PFSettings.blemish.Blemish_maximum_count.group_name,data_types,blem_keys);										// 1
        addDataTypeAndKey(m_PFSettings.blemish.Blemish_size_pixels.data_type, m_PFSettings.blemish.Blemish_size_pixels.group_name,data_types,blem_keys);											// 2
        addDataTypeAndKey(m_PFSettings.blemish.Dead_pixels_max.data_type, m_PFSettings.blemish.Dead_pixels_max.name,data_types,blem_keys);															// 3
        addDataTypeAndKey(m_PFSettings.blemish.Dead_pixel_clusters_max.data_type, m_PFSettings.blemish.Dead_pixel_clusters_max.name,data_types,blem_keys);											// 4
        addDataTypeAndKey(m_PFSettings.blemish.Defective_pixels_max_count.data_type, m_PFSettings.blemish.Defective_pixels_max_count.name,data_types,blem_keys);									// 5
        addDataTypeAndKey(m_PFSettings.blemish.Hot_pixel_clusters_max.data_type, m_PFSettings.blemish.Hot_pixel_clusters_max.name,data_types,blem_keys);											// 6
        addDataTypeAndKey(m_PFSettings.blemish.Hot_pixels_max.data_type, m_PFSettings.blemish.Hot_pixels_max.name,data_types,blem_keys);															// 7
        addDataTypeAndKey(m_PFSettings.blemish.Optical_center_offset_max.data_type, m_PFSettings.blemish.Optical_center_offset_max.name,data_types,blem_keys);										// 8
        addDataTypeAndKey(m_PFSettings.blemish.Optical_center_offset_X_max.data_type, m_PFSettings.blemish.Optical_center_offset_X_max.name,data_types,blem_keys);									// 9
        addDataTypeAndKey(m_PFSettings.blemish.Optical_center_offset_Y_max.data_type, m_PFSettings.blemish.Optical_center_offset_Y_max.name,data_types,blem_keys);									//10
        addDataTypeAndKey(m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max.data_type, m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max.name,data_types,blem_keys);		//11
        addDataTypeAndKey(m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min.data_type, m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min.name,data_types,blem_keys);	//12
        addDataTypeAndKey(m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max.data_type, m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max.name,data_types,blem_keys);						//13
        addDataTypeAndKey(m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max.data_type, m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max.name,data_types,blem_keys);						//14
        // add the contents of blem_keys and data_types to readKeys
        for (std::size_t idx = 0; idx < m_PFSettings.blemish.numEntries; ++idx)
        {
            try
            {
                mwArray key(blem_keys[idx].c_str());
                mwArray value(data_types[idx].c_str());
                mwArray default_ret;

                if (data_types[idx].compare("i") == 0)
                {
                    default_ret = default_0;
                }
                else if (data_types[idx].compare("d") == 0)
                {
                    default_ret = default_dbl;
                }
                else
                {
                    default_ret = default_emptystring;
                }

                getIndex = 1;
                readKeys.Get(2, idx + 1, getIndex++).Set(section_Blemish);
#ifdef INI_INCLUDE_SUBSECTION
                readKeys.Get(2, idx + 1, getIndex++).Set(subsection_blank);
#endif
                readKeys.Get(2, idx + 1, getIndex++).Set(key);
                readKeys.Get(2, idx + 1, getIndex++).Set(value);
                readKeys.Get(2, idx + 1, getIndex++).Set(default_ret);
            }
            catch (exception e)
            {
                string x = "";
            }
        }

        varargin.Get(1,1).Set(passFailFile);
        varargin.Get(1,2).Set(mode_read);
        varargin.Get(1,3).Set(readKeys);
		
        readSett = mwArray(1, m_PFSettings.blemish.numEntries, mxCELL_CLASS);

        try
        {
            inifile(1,readSett,varargin);
        }
        catch (mwException& e)
        {
            cout << "Run Error! Unable to read Blemish keys from Pass/Fail file" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
        }

        // now to copy the values into m_PFSettings.blemish

        std::vector<int> intVecBuf;
        std::size_t vecSize;
         mwArray temp;

        vecSize = readSett.Get(1,1).Get(1,1).NumberOfElements();
        intVecBuf.resize(vecSize);
        temp = readSett.Get(1,1).Get(1,1);
        temp.GetData(&intVecBuf[0], vecSize);
        m_PFSettings.blemish.Blemish_maximum_count.value.resize(vecSize);
        if (intVecBuf[0] != badval)
        {
            for ( std::size_t idx=0; idx < vecSize; ++idx)
            {
                m_PFSettings.blemish.Blemish_maximum_count.value[idx] = intVecBuf[idx];
            }
            m_PFSettings.blemish.Blemish_maximum_count.b_isUsed = true;
        }

        vecSize = readSett.Get(1,1).Get(1,2).NumberOfElements();
        intVecBuf.clear();
        intVecBuf.resize(vecSize);
        m_PFSettings.blemish.Blemish_size_pixels.value.resize(vecSize);
        temp = readSett.Get(1,1).Get(1,2);
        temp.GetData(&intVecBuf[0], vecSize);
        if (intVecBuf[0] != badval)
        {
            for ( std::size_t idx=0; idx < vecSize; ++idx)
            {
                m_PFSettings.blemish.Blemish_size_pixels.value[idx] = intVecBuf[idx];
            }
            m_PFSettings.blemish.Blemish_size_pixels.b_isUsed = true;
        }

        int intBuf = 0;
        double dblBuf = 0.0;
       

        temp = readSett.Get(1,1).Get(1,3);
        temp.GetData(&intBuf, 1);
        m_PFSettings.blemish.Dead_pixels_max.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,4);
        temp.GetData(&intBuf, 1);
        m_PFSettings.blemish.Dead_pixel_clusters_max.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,5);
        temp.GetData(&intBuf, 1);
        m_PFSettings.blemish.Defective_pixels_max_count.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,6);
        temp.GetData(&intBuf, 1);
        m_PFSettings.blemish.Hot_pixel_clusters_max.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,7);
        temp.GetData(&intBuf, 1);
        m_PFSettings.blemish.Hot_pixels_max.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,8);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Optical_center_offset_max.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,9);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Optical_center_offset_X_max.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,10);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Optical_center_offset_Y_max.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,11);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,12);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,13);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,14);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max.assign_value(dblBuf,static_cast<double>(badval));


    }

    if ( m_PFSettings.sfrplus.b_enable)
    {

#ifdef INI_INCLUDE_SUBSECTION
        readKeys = mwArray(m_PFSettings.sfrplus.numEntries, 5, mxCELL_CLASS);
#else
        readKeys = mwArray(m_PFSettings.sfrplus.numEntries, 4, mxCELL_CLASS);
#endif


        mwArray section_sfr(m_PFSettings.sfrplus.name.c_str());

        varargin = mwArray(1,3,mxCELL_CLASS);

        std::vector<std::string> data_types;
        std::vector<std::string> sfr_keys;
        // the entry<T> corresponding to a given index in sfr_keys will correspond to the same index + 1 in readKeys
        addDataTypeAndKey(m_PFSettings.sfrplus.All_Edge_IDs_detected.data_type,m_PFSettings.sfrplus.All_Edge_IDs_detected.name,data_types,sfr_keys);														// 1
        addDataTypeAndKey(m_PFSettings.sfrplus.Bayer_decode.data_type,m_PFSettings.sfrplus.Bayer_decode.name,data_types,sfr_keys);																			// 2
        addDataTypeAndKey(m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds.data_type,m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds.group_name,data_types,sfr_keys);									// 3
        addDataTypeAndKey(m_PFSettings.sfrplus.Chart_radial_pixel_shift_max.data_type,m_PFSettings.sfrplus.Chart_radial_pixel_shift_max.name,data_types,sfr_keys);											// 4
        addDataTypeAndKey(m_PFSettings.sfrplus.Color_expected_detected.data_type,m_PFSettings.sfrplus.Color_expected_detected.name,data_types,sfr_keys);													// 5
        addDataTypeAndKey(m_PFSettings.sfrplus.DeltaE_00_mean_max.data_type,m_PFSettings.sfrplus.DeltaE_00_mean_max.name,data_types,sfr_keys);
        addDataTypeAndKey(m_PFSettings.sfrplus.Convergence_angle_max.data_type,m_PFSettings.sfrplus.Convergence_angle_max.name,data_types,sfr_keys);														// 6
        addDataTypeAndKey(m_PFSettings.sfrplus.FOV_degrees_diagonal_min.data_type,m_PFSettings.sfrplus.FOV_degrees_diagonal_min.name,data_types,sfr_keys);													// 7
        addDataTypeAndKey(m_PFSettings.sfrplus.High_pixel_saturation_fraction_max.data_type,m_PFSettings.sfrplus.High_pixel_saturation_fraction_max.name,data_types,sfr_keys);								// 8
        addDataTypeAndKey(m_PFSettings.sfrplus.Horizontal_bars_OK_min.data_type,m_PFSettings.sfrplus.Horizontal_bars_OK_min.name,data_types,sfr_keys);														// 9
        addDataTypeAndKey(m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max.data_type,m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max.name,data_types,sfr_keys);								//10
        addDataTypeAndKey(m_PFSettings.sfrplus.Mirrored_chart.data_type,m_PFSettings.sfrplus.Mirrored_chart.name,data_types,sfr_keys);																		//11
        addDataTypeAndKey(m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min.data_type,m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min.name,data_types,sfr_keys);											//12
        addDataTypeAndKey(m_PFSettings.sfrplus.MTF50P_ratio_min.data_type,m_PFSettings.sfrplus.MTF50P_ratio_min.name,data_types,sfr_keys);																	//13
        addDataTypeAndKey(m_PFSettings.sfrplus.passfail_ini_file_date.data_type,m_PFSettings.sfrplus.passfail_ini_file_date.name,data_types,sfr_keys);														//14
        addDataTypeAndKey(m_PFSettings.sfrplus.Rotation_degrees_max.data_type,m_PFSettings.sfrplus.Rotation_degrees_max.name,data_types,sfr_keys);															//15
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min.data_type,m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min.name,data_types,sfr_keys);							//16
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min.data_type,m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min.name,data_types,sfr_keys);								//17
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min.data_type,m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min.name,data_types,sfr_keys);								//18
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max.data_type,m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max.name,data_types,sfr_keys);			//19
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min.data_type,m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min.name,data_types,sfr_keys);	//20
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min.data_type,m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min.name,data_types,sfr_keys);							//21
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min.data_type,m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min.name,data_types,sfr_keys);								//22
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min.data_type,m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min.name,data_types,sfr_keys);								//23
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max.data_type,m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max.name,data_types,sfr_keys);			//24
        addDataTypeAndKey(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min.data_type,m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min.name,data_types,sfr_keys);	//25
        addDataTypeAndKey(m_PFSettings.sfrplus.Stepchart_expected_detected.data_type,m_PFSettings.sfrplus.Stepchart_expected_detected.name,data_types,sfr_keys);											//26
        addDataTypeAndKey(m_PFSettings.sfrplus.upside_down.data_type,m_PFSettings.sfrplus.upside_down.name,data_types,sfr_keys);																			//27

        // add the contents of sfr_keys and data_types to readKeys
        for (std::size_t idx = 0; idx < m_PFSettings.sfrplus.numEntries; ++idx)
        {
            mwArray key(sfr_keys[idx].c_str());
            mwArray value(data_types[idx].c_str());
            mwArray default_ret;

            if (data_types[idx].compare("i")==0)
            {
                default_ret = default_0;
            }
            else if(data_types[idx].compare("d")==0)
            {
                default_ret = default_dbl;
            }
            else
            {
                default_ret = default_emptystring;
            }

            getIndex = 1;
            readKeys.Get(2,idx+1,getIndex++).Set(section_sfr);
#ifdef INI_INCLUDE_SUBSECTION
            readKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            readKeys.Get(2,idx+1,getIndex++).Set(key);
            readKeys.Get(2,idx+1,getIndex++).Set(value);
            readKeys.Get(2,idx+1,getIndex++).Set(default_ret);
        }

        int intBuf = 0;
        double dblBuf = 0.0;
        std::vector<int> intVecBuf;
        std::vector<double> dblVecBuf;
        varargin.Get(1,1).Set(passFailFile);
        varargin.Get(1,2).Set(mode_read);
        varargin.Get(1,3).Set(readKeys);
        readSett = mwArray(1,m_PFSettings.sfrplus.numEntries,mxCELL_CLASS);

        try
        {
            inifile(1,readSett,varargin);
        }
        catch (mwException& e)
        {
            cout << "Run Error! Unable to read SFRplus keys from Pass/Fail file" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
        }
        // copy the values read from file to the appropriate entries in m_PFSettings.sfrplus
        mwArray temp;

        temp = readSett.Get(1,1).Get(1,1);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.All_Edge_IDs_detected.assign_value( intBuf,badval);

        temp = readSett.Get(1,1).Get(1,2);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.Bayer_decode.assign_value( intBuf,badval);

        std::size_t vecSize = readSett.Get(1,1).Get(1,3).NumberOfElements();
        dblVecBuf.resize(vecSize);
        temp = readSett.Get(1,1).Get(1,3);
        temp.GetData(&dblVecBuf[0], vecSize);
        m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds.assign_value(dblVecBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,4);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Chart_radial_pixel_shift_max.assign_value( dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,5);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.Color_expected_detected.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,6);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Convergence_angle_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,6);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.DeltaE_00_mean_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,7);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.FOV_degrees_diagonal_min.assign_value(dblBuf,badval);

        temp = readSett.Get(1,1).Get(1,8);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.High_pixel_saturation_fraction_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,9);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.Horizontal_bars_OK_min.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,10);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,11);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.Mirrored_chart.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,12);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,13);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.MTF50P_ratio_min.assign_value(dblBuf,static_cast<double>(badval));

        m_PFSettings.sfrplus.passfail_ini_file_date.value = readSett.Get(1,1).Get(1,14).ToString();
//        m_PFSettings.sfrplus.passfail_ini_file_date.value.remove('\n');
//        m_PFSettings.sfrplus.passfail_ini_file_date.value.remove('\r');
        if (m_PFSettings.sfrplus.passfail_ini_file_date.value.compare(badstring.c_str()) != 0)
        {
            m_PFSettings.sfrplus.passfail_ini_file_date.b_isUsed = true;
            if (m_PFSettings.sfrplus.passfail_ini_file_date.value.compare("[]") == 0)
            {
                m_PFSettings.sfrplus.passfail_ini_file_date.value = "";
            }
        }
        else
        {
            m_PFSettings.sfrplus.passfail_ini_file_date.b_isUsed = false;
        }

        temp = readSett.Get(1,1).Get(1,15);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Rotation_degrees_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,16);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,17);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,18);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,19);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,20);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,21);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,22);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,23);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,24);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,25);
        temp.GetData(&dblBuf, 1);
        m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min.assign_value(dblBuf,static_cast<double>(badval));

        temp = readSett.Get(1,1).Get(1,26);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.Stepchart_expected_detected.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,27);
        temp.GetData(&intBuf, 1);
        m_PFSettings.sfrplus.upside_down.assign_value(intBuf,badval);

    }

    if (m_PFSettings.ois.b_enable)
    {

        readKeys = mwArray(m_PFSettings.ois.numEntries,5,mxCELL_CLASS);
        varargin = mwArray(1,3,mxCELL_CLASS);
        mwArray section_ois(m_PFSettings.ois.name.c_str());

        std::vector<std::string> data_types;
        std::vector<std::string> ois_keys;

        addDataTypeAndKey(m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min.data_type,m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min.name,data_types,ois_keys);	// 1
        addDataTypeAndKey(m_PFSettings.ois.R_improve_ALL_dB_min.data_type,m_PFSettings.ois.R_improve_ALL_dB_min.name,data_types,ois_keys);										// 2
        addDataTypeAndKey(m_PFSettings.ois.R_improve_H_dB_min.data_type,m_PFSettings.ois.R_improve_H_dB_min.name,data_types,ois_keys);											// 3
        addDataTypeAndKey(m_PFSettings.ois.R_improve_V_dB_min.data_type,m_PFSettings.ois.R_improve_V_dB_min.name,data_types,ois_keys);											// 4
        // add the contents of ois_keys and data_types to readKeys
        for (std::size_t idx = 0; idx < m_PFSettings.ois.numEntries; ++idx)
        {
            mwArray key(ois_keys[idx].c_str());
            mwArray value(data_types[idx].c_str());
            mwArray default_ret;

            if (data_types[idx].compare("i")==0)
            {
                default_ret = default_0;
            }
            else if(data_types[idx].compare("d")==0)
            {
                default_ret = default_dbl;
            }
            else
            {
                default_ret = default_emptystring;
            }
            getIndex = 1;
            readKeys.Get(2,idx+1,getIndex++).Set(section_ois);
#ifdef INI_INCLUDE_SUBSECTION
            readKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            readKeys.Get(2,idx+1,getIndex++).Set(key);
            readKeys.Get(2,idx+1,getIndex++).Set(value);
            readKeys.Get(2,idx+1,getIndex++).Set(default_ret);
        }

        int intBuf = 0;
        std::vector<int> intVecBuf;

        varargin.Get(1,1).Set(passFailFile);
        varargin.Get(1,2).Set(mode_read);
        varargin.Get(1,3).Set(readKeys);
        readSett = mwArray(1,m_PFSettings.ois.numEntries,mxCELL_CLASS);

        try
        {
            inifile(1,readSett,varargin);
        }
        catch (mwException& e)
        {
            cout << "Run Error!" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
        }
        // copy the values read from file to the appropriate entries in m_PFSettings.ois
        mwArray temp;
        temp = readSett.Get(1,1).Get(1,1);
        temp.GetData(&intBuf, 1);
        m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,2);
        temp.GetData(&intBuf, 1);
        m_PFSettings.ois.R_improve_ALL_dB_min.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,3);
        temp.GetData(&intBuf, 1);
        m_PFSettings.ois.R_improve_H_dB_min.assign_value(intBuf,badval);

        temp = readSett.Get(1,1).Get(1,4);
        temp.GetData(&intBuf, 1);
        m_PFSettings.ois.R_improve_V_dB_min.assign_value(intBuf,badval);
    }

    return result;
}


bool OperatorConsole::WritePassFail(void)
{
	bool result = false;

    mwArray varargin = mwArray(1,4,mxCELL_CLASS);

    mwArray inifilename(m_PFSettings.m_ini_file.c_str());
    mwArray passfailfilename(m_PFSettings.m_pass_fail_file.c_str());
    mwArray mode("write");
    mwArray style("plain");
    mwArray subsection_blank("");
    mwArray value_int("i"), value_string(""), value_double("d");
    mwSize getIndex = 1;


    if (m_PFSettings.blemish.b_enable)
    {
        mwArray section(m_PFSettings.blemish.name.c_str());
        std::vector<std::string> keys;
        std::vector<std::string> vals;

        addKeysAndValues(m_PFSettings.blemish.Blemish_maximum_count.group_name.c_str(), writeVecEntValueString(m_PFSettings.blemish.Blemish_maximum_count), keys, vals, m_PFSettings.blemish.Blemish_maximum_count.b_isUsed);				// 1
        addKeysAndValues(m_PFSettings.blemish.Blemish_size_pixels.group_name.c_str(),writeVecEntValueString(m_PFSettings.blemish.Blemish_size_pixels),keys,vals,m_PFSettings.blemish.Blemish_size_pixels.b_isUsed);						// 2
        addKeysAndValues(m_PFSettings.blemish.Dead_pixels_max.name.c_str(),writeEntValueString(m_PFSettings.blemish.Dead_pixels_max), keys, vals, m_PFSettings.blemish.Dead_pixels_max.b_isUsed);											// 3
        addKeysAndValues(m_PFSettings.blemish.Dead_pixel_clusters_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Dead_pixel_clusters_max), keys, vals, m_PFSettings.blemish.Dead_pixel_clusters_max.b_isUsed);				// 4
        addKeysAndValues(m_PFSettings.blemish.Defective_pixels_max_count.name.c_str(), writeEntValueString(m_PFSettings.blemish.Defective_pixels_max_count), keys, vals, m_PFSettings.blemish.Defective_pixels_max_count.b_isUsed);		// 5
        addKeysAndValues(m_PFSettings.blemish.Hot_pixel_clusters_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Hot_pixel_clusters_max), keys, vals, m_PFSettings.blemish.Hot_pixel_clusters_max.b_isUsed);					// 6
        addKeysAndValues(m_PFSettings.blemish.Hot_pixels_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Hot_pixels_max), keys, vals, m_PFSettings.blemish.Hot_pixels_max.b_isUsed);											// 7
        addKeysAndValues(m_PFSettings.blemish.Optical_center_offset_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Optical_center_offset_max), keys, vals, m_PFSettings.blemish.Optical_center_offset_max.b_isUsed);			// 8
        addKeysAndValues(m_PFSettings.blemish.Optical_center_offset_X_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Optical_center_offset_X_max), keys, vals, m_PFSettings.blemish.Optical_center_offset_X_max.b_isUsed);	// 9
        addKeysAndValues(m_PFSettings.blemish.Optical_center_offset_Y_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Optical_center_offset_Y_max), keys, vals, m_PFSettings.blemish.Optical_center_offset_Y_max.b_isUsed);	//10
        addKeysAndValues(m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max), keys, vals, m_PFSettings.blemish.Relative_illumination_corner_diff_pct_max.b_isUsed);		//11
        addKeysAndValues(m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min.name.c_str(), writeEntValueString(m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min), keys, vals, m_PFSettings.blemish.Relative_illumination_worst_corner_pct_min.b_isUsed);	//12
        addKeysAndValues(m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max), keys, vals, m_PFSettings.blemish.Uniformity_BoverG_corners_pct_max.b_isUsed);								//13
        addKeysAndValues(m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max.name.c_str(), writeEntValueString(m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max), keys, vals, m_PFSettings.blemish.Uniformity_RoverG_corners_pct_max.b_isUsed);								//14
        // add the contents of keys and vals to writeKeys
        mwArray writeKeys = mwArray(keys.size(),4,mxCELL_CLASS);
        for (std::size_t idx=0; idx < keys.size(); ++idx)
        {
            mwArray key(keys[idx].c_str());
            mwArray val(vals[idx].c_str());
            getIndex = 1;
            writeKeys.Get(2,idx+1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
            writeKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            writeKeys.Get(2,idx+1,getIndex++).Set(key);
            writeKeys.Get(2,idx+1,getIndex++).Set(val);
        }

        varargin.Get(1,1).Set(passfailfilename);
        varargin.Get(1,2).Set(mode);
        varargin.Get(1,3).Set(writeKeys);
        varargin.Get(1,4).Set(style);

        try
        {
            inifile(static_cast<const mwArray>(varargin));
            result = true;
        }
        catch (mwException& e)
        {
            cout << "Run Error! Unable to write to Pass/Fail file" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
            result = false;
        }

    }

    if (m_PFSettings.ois.b_enable)
    {
        mwArray section(m_PFSettings.ois.name.c_str());
        std::vector<std::string> keys;
        std::vector<std::string> vals;

        addKeysAndValues(m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min.name.c_str(), writeEntValueString(m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min), keys, vals, m_PFSettings.ois.L_MTF50_delta2_gain_summary_all_dB_min.b_isUsed);// 1
        addKeysAndValues(m_PFSettings.ois.R_improve_ALL_dB_min.name.c_str(), writeEntValueString(m_PFSettings.ois.R_improve_ALL_dB_min), keys, vals, m_PFSettings.ois.R_improve_ALL_dB_min.b_isUsed);	// 2
        addKeysAndValues(m_PFSettings.ois.R_improve_H_dB_min.name.c_str(), writeEntValueString(m_PFSettings.ois.R_improve_H_dB_min), keys, vals, m_PFSettings.ois.R_improve_H_dB_min.b_isUsed);		// 3
        addKeysAndValues(m_PFSettings.ois.R_improve_V_dB_min.name.c_str(), writeEntValueString(m_PFSettings.ois.R_improve_V_dB_min), keys, vals, m_PFSettings.ois.R_improve_V_dB_min.b_isUsed);		// 4

        mwArray writeKeys = mwArray(keys.size(),4,mxCELL_CLASS);
        // add the contents of keys and vals to writeKeys
        for (std::size_t idx=0; idx < keys.size(); ++idx)
        {
            mwArray key(keys[idx].c_str());
            mwArray val(vals[idx].c_str());
            getIndex = 1;
            writeKeys.Get(2,idx+1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
            writeKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            writeKeys.Get(2,idx+1,getIndex++).Set(key);
            writeKeys.Get(2,idx+1,getIndex++).Set(val);
        }

        varargin.Get(1,1).Set(passfailfilename);
        varargin.Get(1,2).Set(mode);
        varargin.Get(1,3).Set(writeKeys);
        varargin.Get(1,4).Set(style);

        try
        {
            inifile(static_cast<mwArray>(varargin));
            result = true;
        }
        catch (mwException& e)
        {
            cout << "Run Error writing OIS keys to Pass/Fail file!" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
            result = false;
        }

    }

    if (m_PFSettings.other.b_enable)
    {
        mwArray writeKeys = mwArray(m_PFSettings.other.ent_vec.size(),4,mxCELL_CLASS);
        mwArray section(m_PFSettings.other.name.c_str());
        // add the contents of ent_vec to writeKeys
        for (std::size_t idx=0; idx < m_PFSettings.other.ent_vec.size(); ++idx)
        {
            mwArray key(m_PFSettings.other.ent_vec[idx].name.c_str());
            mwArray val(writeEntValueString(m_PFSettings.other.ent_vec[idx]).c_str());
            getIndex = 1;
            writeKeys.Get(2,idx+1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
            writeKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            writeKeys.Get(2,idx+1,getIndex++).Set(key);
            writeKeys.Get(2,idx+1,getIndex++).Set(val);
        }

        varargin.Get(1,1).Set(passfailfilename);
        varargin.Get(1,2).Set(mode);
        varargin.Get(1,3).Set(writeKeys);
        varargin.Get(1,4).Set(style);

        try
        {
            inifile(static_cast<const mwArray>(varargin));
            result = true;
        }
        catch (mwException& e)
        {
            cout << "Run Error writing Blemish keys to Pass/Fail file!" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
            result = false;
        }

    }

    if ( m_PFSettings.sfrplus.b_enable)
    {
        mwArray section(m_PFSettings.sfrplus.name.c_str());
        std::vector<std::string> keys;
        std::vector<std::string> vals;

        addKeysAndValues(m_PFSettings.sfrplus.All_Edge_IDs_detected.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.All_Edge_IDs_detected), keys, vals, m_PFSettings.sfrplus.All_Edge_IDs_detected.b_isUsed);												// 1
        addKeysAndValues(m_PFSettings.sfrplus.Bayer_decode.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Bayer_decode), keys, vals, m_PFSettings.sfrplus.Bayer_decode.b_isUsed);																			// 2
        addKeysAndValues(m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds.group_name.c_str(), writeMinMaxEntValueString(m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds), keys, vals, m_PFSettings.sfrplus.Chart_mean_pixel_level_bounds.b_isUsed);			// 3
        addKeysAndValues(m_PFSettings.sfrplus.Chart_radial_pixel_shift_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Chart_radial_pixel_shift_max), keys, vals, m_PFSettings.sfrplus.Chart_radial_pixel_shift_max.b_isUsed);							// 4
        addKeysAndValues(m_PFSettings.sfrplus.Color_expected_detected.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Color_expected_detected), keys, vals, m_PFSettings.sfrplus.Color_expected_detected.b_isUsed);										// 5
        addKeysAndValues(m_PFSettings.sfrplus.DeltaE_00_mean_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.DeltaE_00_mean_max), keys, vals, m_PFSettings.sfrplus.DeltaE_00_mean_max.b_isUsed);										// 6
        addKeysAndValues(m_PFSettings.sfrplus.Convergence_angle_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Convergence_angle_max), keys, vals, m_PFSettings.sfrplus.Convergence_angle_max.b_isUsed);												// 7
        addKeysAndValues(m_PFSettings.sfrplus.FOV_degrees_diagonal_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.FOV_degrees_diagonal_min), keys, vals, m_PFSettings.sfrplus.FOV_degrees_diagonal_min.b_isUsed);										// 8
        addKeysAndValues(m_PFSettings.sfrplus.High_pixel_saturation_fraction_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.High_pixel_saturation_fraction_max), keys, vals, m_PFSettings.sfrplus.High_pixel_saturation_fraction_max.b_isUsed);		// 9
        addKeysAndValues(m_PFSettings.sfrplus.Horizontal_bars_OK_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Horizontal_bars_OK_min), keys, vals, m_PFSettings.sfrplus.Horizontal_bars_OK_min.b_isUsed);											// 10
        addKeysAndValues(m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max), keys, vals, m_PFSettings.sfrplus.Low_pixel_saturation_fraction_max.b_isUsed);			//11
        addKeysAndValues(m_PFSettings.sfrplus.Mirrored_chart.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Mirrored_chart), keys, vals, m_PFSettings.sfrplus.Mirrored_chart.b_isUsed);																	//12
        addKeysAndValues(m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min), keys, vals, m_PFSettings.sfrplus.MTF50P_CP_weighted_mean_min.b_isUsed);							//13
        addKeysAndValues(m_PFSettings.sfrplus.MTF50P_ratio_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.MTF50P_ratio_min), keys, vals, m_PFSettings.sfrplus.MTF50P_ratio_min.b_isUsed);																//14
        addKeysAndValues(m_PFSettings.sfrplus.passfail_ini_file_date.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.passfail_ini_file_date), keys, vals, m_PFSettings.sfrplus.passfail_ini_file_date.b_isUsed);											//15
        addKeysAndValues(m_PFSettings.sfrplus.Rotation_degrees_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Rotation_degrees_max), keys, vals, m_PFSettings.sfrplus.Rotation_degrees_max.b_isUsed);													//16
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_1_center_mean_min.b_isUsed);	//17
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_1_outer_mean_min.b_isUsed);		//18
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_1_outer_min_min.b_isUsed);			//19
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max), keys, vals, m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_delta_max.b_isUsed);			//20
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_1_outer_quadrant_mean_min_min.b_isUsed);//21
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_2_center_mean_min.b_isUsed);	//22
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_2_outer_mean_min.b_isUsed);		//23
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_2_outer_min_min.b_isUsed);			//24
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max), keys, vals, m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_delta_max.b_isUsed);			//25
        addKeysAndValues(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min), keys, vals, m_PFSettings.sfrplus.Secondary_readout_2_outer_quadrant_mean_min_min.b_isUsed);//26
        addKeysAndValues(m_PFSettings.sfrplus.Stepchart_expected_detected.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.Stepchart_expected_detected), keys, vals, m_PFSettings.sfrplus.Stepchart_expected_detected.b_isUsed);							//27
        addKeysAndValues(m_PFSettings.sfrplus.upside_down.name.c_str(), writeEntValueString(m_PFSettings.sfrplus.upside_down), keys, vals, m_PFSettings.sfrplus.upside_down.b_isUsed);																			//28

        mwArray writeKeys = mwArray(keys.size(),4,mxCELL_CLASS);
        // add the contents of keys and vals to writeKeys
        for (std::size_t idx=0; idx < keys.size(); ++idx)
        {
            mwArray key(keys[idx].c_str());
            mwArray val(vals[idx].c_str());
            getIndex = 1;
            writeKeys.Get(2,idx+1,getIndex++).Set(section);
#ifdef INI_INCLUDE_SUBSECTION
            writeKeys.Get(2,idx+1,getIndex++).Set(subsection_blank);
#endif
            writeKeys.Get(2,idx+1,getIndex++).Set(key);
            writeKeys.Get(2,idx+1,getIndex++).Set(val);
        }

        varargin.Get(1,1).Set(passfailfilename);
        varargin.Get(1,2).Set(mode);
        varargin.Get(1,3).Set(writeKeys);
        varargin.Get(1,4).Set(style);

        try
        {
            inifile(varargin);
            result = true;
        }
        catch (mwException& e)
        {
            cout << "Run Error writing SFRplus keys to Pass/Fail file!" << endl;
            cerr << e.what() << endl;
            e.print_stack_trace();
            result = false;
        }
    }

    return result;
}


void OperatorConsole::SetImatestCamera()
{
	m_camera = &m_imatest_cam;
	m_cameraControl = &m_ImatestCameraControl;
}


void OperatorConsole::SetFileCamera()
{
    m_camera = &m_file_cam;
    m_cameraControl = &m_FileCameraControl;

}

void OperatorConsole::SetQCamera()
{
    m_qcam.Close();
    m_qcam.Open(m_setup.qcam_deviceID);
    m_camera        = &m_qcam;
    m_cameraControl = &m_QCameraControl;
}

bool OperatorConsole::ReadyForTesting()
{
	bool	ready = true;

	//
	// If we're doing an Arbitrary Chart test, make sure that a chart definition file has been selected
	//
	if (m_test == &m_arbitraryChartControl)
	{
        if (!m_arbitraryChart.HaveChartDef())
		{
            QMessageBox::information(m_dlg, "Error", "You must select a Chart Definition file from the Setup Dialog before running the test.");
			ready = false;
		}
	}

	return ready;
}

void OperatorConsole::LogMessage(QString &str, bool timestamp)
{
    m_dlg->log_message(str, timestamp);
}

void OperatorConsole::LogMessage(QTextStream &text, bool timestamp)
{
    QString str = text.readAll();

    LogMessage(str, timestamp);
}

void OperatorConsole::UpdateSummary(QString &results)
{
    m_dlg->update_summary(results);
}


void OperatorConsole::UpdateStatus(bool passed, QString &failInfo)
{
    m_dlg->update_status(passed, failInfo);
}

void OperatorConsole::UpdateFPS(QString &fps)
{
    m_dlg->update_fps(fps);
}


void OperatorConsole::SetupSlots()
{

    connect(&m_blemishControl,        &ThreadControl::data_ready, this, &OperatorConsole::OnBlemishDone);
    connect(&m_sfrPlusControl,        &ThreadControl::data_ready, this, &OperatorConsole::OnSFRplusDone);
    connect(&m_arbitraryChartControl, &ThreadControl::data_ready, this, &OperatorConsole::OnAribtraryChartDone);
    connect(&m_ImatestCameraControl,  &ThreadControl::data_ready, this, &OperatorConsole::OnFrameReady);
    connect(&m_QCameraControl,        &ThreadControl::data_ready, this, &OperatorConsole::OnFrameReady);
    connect(&m_FileCameraControl,     &ThreadControl::data_ready, this, &OperatorConsole::OnFrameReady);
}

void OperatorConsole::TestDone()
{
    if (m_status == runningTest)
    {
        OnRunTest();
    }
    else if (m_status == stopping)
    {
        m_wait.stop();
        m_status = idle;
    }
}
